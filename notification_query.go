package wmi

import (
	"errors"
	"fmt"
	"reflect"
	"runtime"
	"sync"
	"time"

	"github.com/go-ole/go-ole"
	"github.com/go-ole/go-ole/oleutil"
)

var (
	// ErrAlreadyRunning is returned when NotificationQuery is already running.
	ErrAlreadyRunning = errors.New("already running")
)

const (
	wbemErrTimedOut            = 0x80043001
	defaultNotificationTimeout = time.Second
)

// NotificationQuery represents subscription to the WMI events.
// For more info see https://docs.microsoft.com/en-us/windows/desktop/wmisdk/swbemservices-execnotificationquery
type NotificationQuery struct {
	sync.Mutex
	query             string
	isRunning         bool
	doneCh            chan struct{}
	eventCh           interface{}
	connectServerArgs []interface{}
	queryTimeoutMs    int64
}

// NewNotificationQuery creates a NotificationQuery from the given WQL @query
// string. The method just creates the object and does no WMI calls, so all WMI
// errors (query syntax, connection, etc.) will be returned on query start.
//
// @eventCh should be a channel of structures or structure pointers. The
// structure type should satisfy limitations described in `Decoder.Unmarshal`.
//
// Returns error if @eventCh is not `chan T` nor `chan *T`.
func NewNotificationQuery(eventCh interface{}, query string) (*NotificationQuery, error) {
	if !isChannelTypeOK(eventCh) {
		return nil, errors.New("eventCh has incorrect type; should be `chan T` or `chan *T`")
	}
	q := NotificationQuery{
		eventCh: eventCh,
		query:   query,
	}
	q.SetNotificationTimeout(defaultNotificationTimeout)
	return &q, nil
}

// SetNotificationTimeout specifies a time query could send waiting for the next
// event at the worst case. Waiting for the next event locks notification thread
// so in other words @t specifies a time for notification thread to react to the
// `Stop()` command at the worst.
//
// Default NotificationTimeout is 1s. It could be safely changed after the query
// `Start()`.
//
// Setting it to negative Duration makes that interval infinite.
func (q *NotificationQuery) SetNotificationTimeout(t time.Duration) {
	if t < 0 {
		q.queryTimeoutMs = -1
	}
	q.queryTimeoutMs = int64(t / time.Microsecond)
}

// SetConnectServerArgs sets `SWbemLocator.ConnectServer` args. Args are
// directly passed to `ole` call and support most of primitive types.
//
// Args reference: https://docs.microsoft.com/en-us/windows/desktop/wmisdk/swbemlocator-connectserver
// Passing details: https://github.com/go-ole/go-ole/blob/master/idispatch_windows.go#L60
func (q *NotificationQuery) SetConnectServerArgs(args ...interface{}) {
	q.connectServerArgs = args
}

// StartNotifications connects to the WMI service and starts receiving
// notifications generated by the query.
//
// Errors are usually happen on initialization phase (connect to WMI,
// query execution, first result unmarshalling) so you could assume that
// "it's either starts and going to give me notifications or fails fast enough".
func (q *NotificationQuery) StartNotifications() error {
	q.Lock()
	if q.isRunning {
		q.Unlock()
		return ErrAlreadyRunning
	}
	q.isRunning = true
	q.Unlock()

	// TODO: change COM initialization
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	err := ole.CoInitializeEx(0, ole.COINIT_MULTITHREADED)
	if err != nil {
		oleCode := err.(*ole.OleError).Code()
		if oleCode != ole.S_OK && oleCode != S_FALSE {
			return fmt.Errorf("ole.CoInitializeEx error: %v", err)
		}
	}
	defer ole.CoUninitialize()

	// Connect to WMI service.
	service, err := createWMIConnection(q.connectServerArgs...)
	if err != nil {
		return fmt.Errorf("failed to connect WMI service; %s", err)
	}
	defer service.Release()

	// Subscribe to the events.
	// TODO: add named flags from other fork.
	sWbemEventSource, err := oleutil.CallMethod(
		service,
		"ExecNotificationQuery",
		q.query,
		"WQL",
		0x00000010|0x00000020, // WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY
	)
	if err != nil {
		return fmt.Errorf("ExecNotificationQuery failed; %s", err)
	}
	eventSource := sWbemEventSource.ToIDispatch()
	defer eventSource.Release()

	for {
		// If it is a time to stop - return.
		if q.doneCh != nil {
			close(q.doneCh)
			return nil
		}
		// Or try to query new events waiting no longer than queryTimeoutMs.
		eventIUknown, err := eventSource.CallMethod("NextEvent", q.queryTimeoutMs)
		if err != nil {
			if isTimeoutError(err) {
				continue
			}
			return fmt.Errorf("unexpected NextEvent error; %s", err)
		}
		event := eventIUknown.ToIDispatch()

		// Do something with event
		_ = event
	}
}

// Stop stops the running query waiting until everything is released. It could
// take some time for query to receive a stop signal. See `SetNotificationTimeout`
// for more info.
func (q *NotificationQuery) Stop() {
	q.Lock()
	defer q.Unlock()
	if q.isRunning {
		return
	}
	q.doneCh = make(chan struct{})
	<-q.doneCh
	q.isRunning = false
}

func createWMIConnection(connectServerArgs ...interface{}) (wmi *ole.IDispatch, err error) {
	sWbemLocatorIUnknown, err := oleutil.CreateObject("WbemScripting.SWbemLocator")
	if err != nil {
		return nil, fmt.Errorf("failed to create SWbemLocator; %s", err)
	} else if sWbemLocatorIUnknown == nil {
		return nil, ErrNilCreateObject
	}
	defer sWbemLocatorIUnknown.Release()

	sWbemLocatorIDispatch, err := sWbemLocatorIUnknown.QueryInterface(ole.IID_IDispatch)
	if err != nil {
		return nil, fmt.Errorf("SWbemLocator.QueryInterface failed ; %s", err)
	}
	defer sWbemLocatorIDispatch.Release()

	serviceRaw, err := oleutil.CallMethod(sWbemLocatorIDispatch, "ConnectServer", connectServerArgs...)
	if err != nil {
		return nil, fmt.Errorf("SWbemLocator.ConnectServer failed; %s", err)
	}
	return serviceRaw.ToIDispatch(), nil
}

func isTimeoutError(err error) bool {
	oleErr, ok := err.(*ole.OleError)
	return ok && oleErr.Code() == wbemErrTimedOut
}

func isChannelTypeOK(eventCh interface{}) bool {
	chT := reflect.TypeOf(eventCh)
	if chT.Kind() != reflect.Chan {
		return false
	}
	elemT := chT.Elem()
	switch elemT.Kind() {
	case reflect.Struct:
		return true
	case reflect.Ptr:
		return elemT.Elem().Kind() == reflect.Struct
	}
	return false
}
